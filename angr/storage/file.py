import claripy
import logging
import itertools

from .memory_object import SimMemoryObject
from ..state_plugins.plugin import SimStatePlugin
from ..state_plugins.sim_action_object import SimActionObject
from ..state_plugins.symbolic_memory import SimSymbolicMemory
from .. import sim_options

l = logging.getLogger("angr.storage.file")

file_counter = itertools.count()
dialogue_counter = itertools.count()

class Flags: # pylint: disable=W0232,
    O_RDONLY = 0
    O_WRONLY = 1
    O_RDWR = 2
    O_ACCMODE = 3 # bitmask for read/write mode
    O_APPEND = 4096
    O_ASYNC = 64
    O_CLOEXEC = 512
    # TODO mode for this flag
    O_CREAT = 256
    O_DIRECT = 262144
    O_DIRECTORY = 2097152
    O_EXCL = 2048
    O_LARGEFILE = 1048576
    O_NOATIME = 16777216
    O_NOCTTY = 1024
    O_NOFOLLOW = 4194304
    O_NONBLOCK = 8192
    O_NODELAY = 8192
    O_SYNC = 67174400
    O_TRUNC = 1024


def _deps_unpack(a):
    if isinstance(a, SimActionObject):
        return a.ast, a.reg_deps, a.tmp_deps
    else:
        return a, None, None

class SimFileBase(SimStatePlugin):
    """
    SimFiles are the storage mechanisms used by SimFileDescriptors.

    Different types of SimFiles can have drastically different interfaces, and as a result there's not much that can be
    specified on this base class.

    :ivar name:     The name of the file. Purely for cosmetic purposes
    :ivar ident:    The identifier of the file, typically autogenerated from the name and a nonce. Purely for cosmetic
                    purposes, but does appear in symbolic values autogenerated in the file.
    :ivar seekable: Bool indicating whether seek operations on this file should succeed.
    :ivar writable: Bool indicating whether writing to this file is allowed.
    """

    seekable = False

    def __init__(self, name, writable=True, ident=None, **kwargs):
        self.name = name
        self.ident = ident
        self.writable = writable

        if ident is None:
            nice_name = self.name if all(0x20 <= ord(c) <= 0x7f for c in self.name) else '???'
            self.ident = 'file_%d_%s' % (next(file_counter), nice_name)

        if 'memory_id' in kwargs:
            kwargs['memory_id'] = self.ident
        super(SimFileBase, self).__init__(**kwargs)

    def concretize(self):
        """
        Return a concretization of the contents of the file. The type of the return value of this method will vary
        depending on which kind of SimFile you're using.
        """
        raise NotImplementedError

    def read(self, pos, size):
        """
        Read some data from the file.

        :param pos:     The offset in the file to read from. May be ignored if the file is a stream or device.
        :param size:    The size to read. May be symbolic.
        :return:        A tuple of the data read (a bitvector of the length that is the maximum length of the read), the actual size of the read, and the new file position pointer.
        """
        raise NotImplementedError

    def write(self, pos, data, size=None):
        """
        Write some data to the file.

        :param pos:     The offset in the file to write to. May be ignored if the file is a stream or device.
        :param data:    The data to write as a bitvector
        :param size:    The optional size of the data to write. If not provided will default to the length of the data.
                        Must be constrained to less than or equal to the size of the data.
        :return:        The new file position pointer.
        """
        raise NotImplementedError

class SimFile(SimFileBase, SimSymbolicMemory):
    """
    The normal SimFile is meant to files on disk. It subclasses SimSymbolicMemory so loads and stores to/from
    it are very simple.

    :param name:        The name of the file
    :param content:     Optional initial content for the file as a string or bitvector
    :param size:        Optional size of the file. If content is specified, it defaults to its length, otherwise to an
                        unconstrained symbolic variable.
    :param seekable:    Optional bool indicating whether seek operations on this file should succeed, default True.
    :param writable:    Whether writing to this file is allowed

    :ivar size:         The size of the file. Reads past this size will be truncated. Symbolic-valued sizes will be
                        handled as best as possible.
    """
    def __init__(self, name, content=None, size=None, seekable=True, writable=True, ident=None, **kwargs):
        super(SimFile, self).__init__(name, writable=writable, ident=ident, memory_id='file', **kwargs)
        self.size = size
        self.seekable = seekable

        # this is hacky because we need to work around not having a state yet
        if type(content) is bytes:
            content = claripy.BVV(content)
        elif type(content) is claripy.BV:
            pass
        else:
            raise TypeError("Can't handle SimFile content of type %s" % type(content))

        if content is not None:
            mo = SimMemoryObject(content, 0, length=len(content)//8)
            self.mem.store_memory_object(mo)

            if self.size is None:
                self.size = len(content) // 8

    def set_state(self, state):
        super(SimFile, self).set_state(state)
        if self.size is None and sim_options.UNKNOWN_FILES_HAVE_EOF in state.options:
            self.size = claripy.BVS('filesize_%s' % self.ident, state.arch.bits)

    def concretize(self):
        """
        Return a concretization of the contents of the file, as a flat bytestring.
        """
        if self.size is None:
            size = max(self.mem.keys())
        else:
            size = self.state.solver.min(self.size)

        data = self.load(0, size)
        return self.state.solver.eval(data, cast_to=str)

    def read(self, pos, size):
        # If it's not possible to EOF (because there's no EOF), this is very simple!
        if self.size is None:
            return self.load(pos, size), size

        # This is the size if we're reading to the end of the file
        absolute_max_size = self.size - pos
        absolute_max_size = claripy.If(claripy.SLE(absolute_max_size, 0), 0, absolute_max_size)

        # try to frontload some constraint solving to see if it's impossible for this read to EOF
        if self.state.solver.satisfiable(extra_constraints=(size > absolute_max_size,)):
            # it's possible to EOF
            real_size = claripy.If(size >= absolute_max_size, absolute_max_size, size)
            return self.load(pos, absolute_max_size), real_size
        else:
            # it's not possible to EOF
            # we don't need to constrain or min/max the output size because there are already constraints asserting
            # that the total filesize is pretty big
            return self.load(pos, size), size, size + pos

    def write(self, pos, data, size=None):
        if size is None:
            size = len(data) // 8
        # \(_^^)/
        self.store(pos, data, size=size)
        new_end = _deps_unpack(pos + size)[0] # decline to store SAO
        if self.size is not None:
            self.size = claripy.If(new_end > self.size, new_end, self.size)
        return new_end

    @SimStatePlugin.memo
    def copy(self, _):
        #l.debug("Copying %d bytes of memory with id %s." % (len(self.mem), self.id))
        return SimFile(name=self.name, size=self.size, seekable=self.seekable, writable=self.writable, ident=self.ident,
            mem=self.mem.branch(),
            memory_id=self.id,
            endness=self.endness,
            abstract_backer=self._abstract_backer,
            read_strategies=[ s.copy() for s in self.read_strategies ],
            write_strategies=[ s.copy() for s in self.write_strategies ],
            stack_region_map=self._stack_region_map,
            generic_region_map=self._generic_region_map
        )

    def merge(self, others, merge_conditions, common_ancestor=None):
        if not all(isinstance(o, SimFile) for o in others):
            raise SimMergeError("Cannot merge files of disparate type")

        all_files = list(others) + [ self ]

        if all(o.size is None for o in all_files):
            pass
        elif any(o.size is None for o in all_files):
            raise SimMergeError("Cannot merge files where some have sizes and some don't")
        else:
            self.size = self.state.solver.ite_cases(zip(merge_conditions[1:], (o.size for o in others)), self.size)

        return super(SimFile, self).merge(
            [ super(SimFile, o) for o in others ], merge_conditions, common_ancestor
        )

    def widen(self, _):
        raise SimMergeError("Widening the filesystem is unsupported")


class SimPackets(SimFileBase):
    """
    The SimPackets is meant to model inputs whose content is delivered a series of asynchronous chunks. The data is
    stored as a list of read or write results. For symbolic sizes, state.libc.max_packet_size will be respected. If
    the SHORT_READS option is enabled, reads will return a symbolic size constrained to be less than or equal to the
    requested size.

    A SimPackets cannot be used for both reading and writing - for socket objects that can be both read and written to
    you should use a file descriptor to multiplex the read and write operations into two separate file storage
    mechanisms.

    :param name:        The name of the file, for cosmetic purposes
    :param write_mode:  Whether this file is opened in read or write mode. If this is unspecified it will be
                        autodetected.
    :param content:     Some initial content to use for the file. Can be a list of bytestrings or a list SimPacket
                        objects (not SimPackets! individual packets! welcome to OO hell!)

    :ivar write_mode:   See the eponymous parameter
    :ivar content:      A list of packets, as SimPacket objects
                        and the actual length of the packet
    """
    def __init__(self, name, write_mode=None, content=None, writable=True, ident=None, **kwargs):
        super(SimPackets, self).__init__(name, writable=writable, ident=ident, **kwargs)

        self.write_mode = write_mode
        self.content = content

        if self.content is None:
            self.content = []
        else:
            self.content = [
                    x if type(x) is tuple \
                    else (x, len(x) // 8) if type(x) is claripy.BV \
                    else (claripy.BVV(x), len(x)) if type(x) is bytes \
                    else None \
                    for x in self.content]
            if any(x is None for x in self.content):
                raise TypeError("Bad type in initial SimPacket content")

    def concretize(self, **kwargs):
        """
        Returns a list of the packets read or written as bytestrings.
        """
        lengths = [self.state.solver.eval(x[1], **kwargs) for x in self.content]
        kwargs['cast_to'] = bytes
        return ['' if i == 0 else self.state.solver.eval(x[0].get_bytes(0, i), **kwargs) for i, x in zip(lengths, self.content)]

    def read(self, addr, size):
        """
        Read a packet from the stream.

        :param int addr:    The packet number to read from the sequence of the stream. May be None to append to the stream.
        :param size:        The size to read. May be symbolic.
        :return:            A tuple of the data read (a bitvector of the length that is the maximum length of the read) and the actual size of the read.
        """
        # sanity check on read/write modes
        if self.write_mode is None:
            self.write_mode = False
        elif self.write_mode is True:
            raise SimFileError("Cannot read and write to the same SimPackets")

        # sanity check on packet number and determine if data is already present
        if addr is None:
            addr = len(self.content)
        if addr < 0:
            raise SimFileError("SimPacket.read(%d): Negative packet number?", addr)
        elif addr > len(self.content):
            raise SimFileError("SimPacket.read(%d): Packet number is past frontier of %d?", addr, len(self.content))
        elif addr != len(self.content):
            _, realsize = self.content[addr]
            self.state.solver.add(size <= realsize)
            if not self.state.solver.satisfiable():
                raise SimFileError("Packet read size constraint made state unsatisfiable???")
            return self.content[addr] + (addr+1,)

        # The read is on the frontier. let's generate a new packet.
        orig_size = size
        max_size = None

        # if short reads are enabled, replace size with a symbol
        if sim_options.SHORT_READS in self.state.options:
            size = self.state.solver.BVS('packetsize_%d_%s' % (len(self.content), self.ident), self.state.arch.bits)
            self.state.solver.add(size <= orig_size)

        # figure out the maximum size of the read
        if not self.state.solver.symbolic(size):
            max_size = self.state.solver.eval(size)
        elif self.state.solver.satisfiable(extra_constraints=(size <= self.state.libc.max_packet_size,)):
            l.info("Constraining symbolic packet size to be less than %d", self.state.libc.max_packet_size)
            self.state.solver.add(size <= self.state.libc.max_packet_size)
            if not self.state.solver.symbolc(orig_size):
                max_size = min(orig_size, self.state.libc.max_packet_size)
            else:
                max_size = self.state.solver.max(size)
        else:
            max_size = self.state.solver.min(size)
            l.warning("Could not constrain symbolic packet size to <= %d; using minimum %d for size", self.state.libc.max_packet_size, max_size)
            self.state.solver.add(size == max_size)

        # generate the packet data and return it
        data = claripy.BVS('packet_%d_%s' % (len(self.content), self.ident), max_size * 8)
        packet = (data, size)
        self.content.append(packet)
        return packet + (addr+1,)

    def write(self, addr, data, size=None):
        """
        Write a packet to the stream.

        :param int addr:    The packet number to write in the sequence of the stream. May be None to append to the stream.
        :param data:        The data to write, as a string or bitvector.
        :param size:        The optional size to write. May be symbolic; must be constrained to at most the size of data.
        :return:            The next packet to use after this
        """
        # sanity check on read/write modes
        if self.write_mode is None:
            self.write_mode = True
        elif self.write_mode is False:
            raise SimFileError("Cannot read and write to the same SimPackets")

        if type(data) is bytes:
            data = claripy.BVV(data)
        if size is None:
            size = len(data) // 8

        # sanity check on packet number and determine if data is already present
        if addr < 0:
            raise SimFileError("SimPacket.write(%d): Negative packet number?", addr)
        elif addr > len(self.content):
            raise SimFileError("SimPacket.write(%d): Packet number is past frontier of %d?", addr, len(self.content))
        elif addr != len(self.content):
            realdata, realsize = self.content[addr]
            maxlen = max(len(realdata), len(data))
            self.state.solver.add(realdata[maxlen-1:0] == data[maxlen-1:0])
            self.state.solver.add(size == realsize)
            if not self.state.solver.satisfiable():
                raise SimFileError("Packet write equality constraints made state unsatisfiable???")
            return addr+1

        # write it out!
        self.content.append((data, size))
        return addr+1

    @SimStatePlugin.memo
    def copy(self, memo):
        return SimPackets(self.name, write_mode=self.write_mode, content=self.content, ident=self.ident)

    def merge(self, others, conditions, _=None):
        for o in others:
            if o.write_mode is None:
                continue
            elif self.write_mode is None:
                self.write_mode = o.write_mode
            elif self.write_mode is not o.write_mode:
                raise SimMergeError("Cannot merge SimPackets with disparate write_mode")

        for o in others:
            if len(o.content) != len(self.content):
                raise SimMergeError("Cannot merge SimPackets with disparate number of packets")

        for i, default in enumerate(self.content):
            max_data_length = max(len(default[0]), max(len(o.content[i][0]) for o in others))
            merged_data = self.state.solver.ite_cases(
                zip(
                    conditions[1:],
                    (o.content[i][0].concat(claripy.BVV(0, max_data_length - len(o.content[i][0]))) for o in others)
                ), default[0])
            merged_size = self.state.solver.ite_cases(zip(conditions[1:], (o.content[i][1] for o in others)), default[1])
            self.content[i] = (merged_data, merged_size)

        return True

    def widen(self, _):
        raise SimMergeError("Widening the filesystem is unsupported")

class SimPacket(object):
    """
    An individual packet of data. This is a base class for representing several kinds of packet data.
    """
    max_length = None
    sym_length = None

    def decompose(self):
        """
        Return data and constraints necessary to represent this packet in a flat address space
        """
        raise NotImplementedError

    def concretize(self, state):
        """
        Return a string for the packet satisfying the constraints currently on the state
        """
        raise NotImplementedError

    def concat(self, *others):
        members = sum(x.members if type(x) is SimPacketConcat else [x] for x in [self] + others)
        return SimPacketConcat(members)

class SimPacketConstant(SimPacket):
    def __init__(self, string):
        self.string = string
        self.max_length = len(string)
        self.sym_length = claripy.BVV(self.max_length, 64)

    def concretize(self, state):
        return self.string

class SimPacketString(SimPacket):
    pass # variable length string with character membership restrictions

class SimPacketInteger(SimPacket): # TODO: unsigned, other representations
    def __init__(self, state, name, bits):
        self.max_length = len(str(2**bits - 1)) + 1
        self.integer = state.solver.BVS(name, bits)

    def concretize(self, state):
        return str(state.solver.eval(self.integer))

class SimPacketConcat(SimPacket):
    def __init__(self, members):
        self.members = members
        self.max_length = sum(x.max_length for x in self.members)
        self.sym_length = sum(x.sym_length for x in self.members)

    def concretize(self, state):
        return ''.join(member.concretize(state) for member in self.members)


#class SimFileConcrete(SimFileBase):
#    """
#    A SimFile which forwards all its reads and writes to the host filesystem.
#
#    :param host_path:   The path in the host filesystem to use
#    :param writable:    Whether to open this file for writing. If the file may not be opened for writing, this will be
#                        ignored.
#    """
#    def __init__(self, host_path, writable=False):
#        super(SimFileConcrete, self).__init__(host_path, writable=writable)
#        self.host_path = host_path
#        try:
#            self.host_file = open(host_path, 'r+b' if writable else 'rb')
#        except OSError:
#            if not writable:
#                raise
#            self.host_file = open(host_path, 'rb')
#
#    def concretize(self):
#        self.host_file.seek(0)
#        return self.host_file.read()
#
#    def read(self, pos, size):
#        conc_size = self.state.solver.max(size)
#        if self.state.solver.symbolic(size):
#            self.state.solver.add(size == conc_size)
#            l.info("Concretizing read size for concrete filesystem to %d", conc_size)
#
#        conc_pos = self.state.solver.eval(pos)
#        self.state.solver.add(pos == conc_pos)
#
#        self.host_file.seek(conc_pos)
#        data = self.host_file.read(conc_size)
#        return self.state.solver.BVV(data), len(data)
#
#    def write(self, pos, data, size=None):
#        if size is None:
#            size = len(data)
#
#        conc_size = self.state.solver.max(size)
#        if self.state.solver.symbolic(size):
#            self.state.solver.add(size == conc_size)
#            l.info("Concretizing write size for concrete filesystem to %d", conc_size)
#
#        data_slice = data.get_bytes(0, conc_size)
#        conc_data = self.state.solver.eval(data_slice, cast_to=str)
#        if self.state.solver.symbolic(data_slice):
#            self.state.solver.add(data_slice == conc_data)
#            l.info("Concretizing write data for concrete filesystem to %r", conc_data)
#
#        conc_pos = self.state.solver.eval(pos)
#        self.state.solver.add(pos == conc_pos)
#
#        self.host_file.seek(conc_pos)
#        self.host_file.write(conc_data)
#
#    def copy(self, _):
#        # this holds no mutable data
#        return self
#
#    def merge(self, others, conditions, ancestor=None): # pylint: disable=unused-argument
#        l.error("The concept of merging concrete files doesn't make sense...")
#        return False
#
#    def widen(self, others):
#        return self.merge(others, [])


class SimFileDescriptorBase(SimStatePlugin):
    """
    The base class for implementations of POSIX file descriptors.

    All file descriptors should respect the CONCRETIZE_SYMBOLIC_{READ,WRITE}_SIZES state options.
    """

    def read(self, addr, size):
        """
        Reads some data from the file, storing it into memory.

        :param addr:    The address to write the read data into memory
        :param size:    The requested length of the read
        :return:        The real length of the read
        """
        data, realsize = self.read_data(size)
        self.state.memory.store(addr, data, size=realsize)
        return realsize

    def write(self, addr, size):
        """
        Writes some data, loaded from the state, into the file.

        :param addr:    The address to read the data to write from in memory
        :param size:    The requested size of the write
        :return:        The real length of the write
        """
        if type(addr) is str:
            raise TypeError("SimFileDescriptor.write takes an address and size. Did you mean write_data?")
        data = self.state.memory.load(addr, size)
        return self.write_data(data, size)

    def read_data(self, size):
        """
        Reads some data from the file, returning the data.

        :param size:    The requested length of the read
        :return:        A tuple of the real length of the read and the data read
        """
        raise NotImplementedError

    def write_data(self, data, size=None):
        """
        Write some data, provided as an argument into the file.

        :param data:    A bitvector to write into the file
        :param size:    The requested size of the write (may be symbolic)
        :return:        The real length of the write
        """
        raise NotImplementedError

    def seek(self, pos, whence='start'):
        """
        Seek the file descriptor to a different position in the file.

        :param offset:  The offset to seek to, interpreted according to whence
        :param whence:  What the offset is relative to; one of the strings "start", "current", or "end"
        :return:        A symbolic boolean describing whether the seek succeeded or not
        """
        raise NotImplementedError

    def tell(self):
        """
        Return the current position, or None if the concept doesn't make sense for the given file.
        """
        raise NotImplementedError

    def eof(self):
        """
        Return the EOF status. May be a symbolic boolean.
        """
        raise NotImplementedError

    @property
    def read_storage(self):
        """
        Return the SimFile backing reads from this fd
        """
        raise NotImplementedError

    @property
    def write_storage(self):
        """
        Return the SimFile backing writes to this fd
        """
        raise NotImplementedError

    def _prep_read(self, size):
        return self._prep_generic(size, True)
    def _prep_write(self, size):
        return self._prep_generic(size, False)

    def _prep_generic(self, size, is_read):
        option = sim_options.CONCRETIZE_SYMBOLIC_FILE_READ_SIZES if is_read else sim_options.CONCRETIZE_SYMBOLIC_WRITE_SIZES
        string = 'read' if is_read else 'write'
        # check if we need to concretize the length
        if option in self.state.options and self.state.solver.symbolic(size):
            try:
                size = self.state.solver.max(size, extra_constraints=(size <= self.state.libc.max_packet_size,))
            except SimSolverError:
                size = self.state.solver.min(size)
            l.info("Concretizing symbolic %s size to %d", string, size)

        return size

class SimFileDescriptor(SimFileDescriptorBase):
    """
    A simple file descriptor forwarding reads and writes to a SimFile. Contains information about
    the current opened state of the file, such as the flags or (if relevant) the current position.

    :ivar file:     The SimFile described to by this descriptor
    :ivar flags:    The mode that the file descriptor was opened with, a bitfield of flags
    """
    def __init__(self, simfile, flags):
        super(SimFileDescriptor, self).__init__()
        self.file = simfile
        self._pos = 0
        self.flags = flags

    def read_data(self, size):
        size = self._prep_read(size)
        data, realsize, self._pos = self.file.read(self._pos, size)
        return data, realsize

    def write_data(self, data, size=None):
        if self.flags & Flags.O_APPEND and getattr(self.file, 'size', None) is not None:
            self._pos = self.file.size

        if size is None:
            size = self.state.solver.BVV(len(data)//8, self.state.arch.bits)

        size = self._prep_write(size)
        self._pos = self.file.write(self._pos, data, size)
        return size

    def seek(self, offset, whence='start'):
        if not self.file.seekable:
            return claripy.false

        if whence == 'start':
            new_pos = offset
        elif whence == 'current':
            new_pos = self._pos + offset
        elif whence == 'end':
            if self.file.size is None:
                raise SimFileError("Cannot seek based on end of file with no end")
            new_pos = self.file.size + offset

        success_condition = claripy.SGE(new_pos, 0)
        if self.file.size is not None:
            success_condition = claripy.And(success_condition, claripy.SLE(new_pos, self.file.size))
        self._pos = _deps_unpack(claripy.If(success_condition, new_pos, self._pos))[0]
        return success_condition

    def eof(self):
        if not self.file.seekable:
            return claripy.false
        if self.file.size is None:
            return claripy.false
        return self._pos == self.file.size

    def tell(self):
        if self.file.seekable:
            return None
        return self._pos

    @property
    def read_storage(self):
        return self.file
    @property
    def write_storage(self):
        return self.file

    def set_state(self, state):
        super(SimFileDescriptor, self).set_state(state)
        self.file.set_state(state)

    @SimStatePlugin.memo
    def copy(self, memo):
        c = SimFileDescriptor(self.file.copy(memo), self.flags)
        c._pos = self._pos
        return c

    def merge(self, others, conditions, ancestor=None):
        # do NOT merge file content - descriptors do not have ownership, prevent duplicate merging
        if not all(type(o) is type(self) for o in others):
            l.error("Cannot merge SimFileDescriptors of disparate types")
            return False
        if not all(o.flags == self.flags for o in others):
            l.error("Cannot merge SimFileDescriptors of disparate flags")
            return False

        if hasattr(self.file, 'size'):
            self._pos = self.state.solver.ite_cases(zip(conditions[1:], (o._pos for o in others)), self._pos)
        else:
            if not all(o._pos == self._pos for o in others):
                l.error("Cannot merge SimFileDescriptors over SimPackets with disparate number of packets")
                return False

        return True

    def widen(self, _):
        raise SimMergeError("Widening the filesystem is unsupported")

class SimFileDescriptorDuplex(SimFileDescriptorBase):
    """
    A file descriptor that refers to two file storage mechanisms, one to read from and one to write to.

    :param read_file:   The SimFile to read from
    :param write_file:  The SimFile to write to
    """
    def __init__(self, read_file, write_file):
        super(SimFileDescriptorDuplex, self).__init__()
        self._read_file = read_file
        self._write_file = write_file

        self._read_pos = 0
        self._write_pos = 0

    def read_data(self, size):
        size = self._prep_read(size)
        data, realsize, self._read_pos = self._read_file.read(self._read_pos, size)
        return data, realsize

    def write_data(self, data, size=None):
        if size is None:
            size = self.state.solver.BVV(len(data)//8, self.state.arch.bits)

        size = self._prep_write(size)
        self._write_pos = self._write_file.write(self._write_pos, data, size)
        return size

    def set_state(self, state):
        super(SimFileDescriptorDuplex, self).set_state(state)
        self._read_file.set_state(state)
        self._write_file.set_state(state)

    def eof(self):
        return claripy.false

    def tell(self):
        return None

    def seek(self, pos, whence='start'):
        return claripy.false

    @property
    def read_storage(self):
        return self._read_file
    @property
    def write_storage(self):
        return self._write_file

    @SimStatePlugin.memo
    def copy(self, memo):
        c = SimFileDescriptorDuplex(self._read_file.copy(memo), self._write_file.copy(memo))
        c._read_pos = self._read_pos
        c._write_pos = self._write_pos
        return c

    def merge(self, others, conditions, ancestor=None):
        # do NOT merge storage mechanisms here - fs and posix handle that
        if not all(type(o) is type(self) for o in others):
            raise SimMergeError("Cannot merge SimFileDescriptors of disparate types")

        if hasattr(self._read_file, 'size'):
            self._read_pos = self.state.solver.ite_cases(zip(conditions[1:], (o._read_pos for o in others)), self._read_pos)
        else:
            if not all(o._read_pos == self._read_pos for o in others):
                raise SimMergeError("Cannot merge SimFileDescriptors over SimPackets with disparate number of packets")

        if hasattr(self._write_file, 'size'):
            self._write_pos = self.state.solver.ite_cases(zip(conditions[1:], (o._write_pos for o in others)), self._write_pos)
        else:
            if not all(o._write_pos == self._write_pos for o in others):
                raise SimMergeError("Cannot merge SimFileDescriptors over SimPackets with disparate number of packets")

        return True

    def widen(self, _):
        raise SimMergeError("Widening the filesystem is unsupported")

# OLD
#class SimFile(SimStatePlugin):
#    """
#    Represents a file.
#    """
#
#    # Creates a SimFile
#    def __init__(self, name, mode, pos=0, content=None, size=None, closed=None):
#        super(SimFile, self).__init__()
#        self.name = name
#        self.mode = mode
#
#        self.pos = pos
#
#        self.size = size
#
#        self.content = SimSymbolicMemory(memory_id="file_%s_%d" % (name, file_counter.next())) if content is None else content
#        self.closed = False if closed is None else closed
#
#    @property
#    def read_pos(self):
#        return self.pos
#
#    @read_pos.setter
#    def read_pos(self, val):
#        self.pos = val
#
#    @property
#    def write_pos(self):
#        return self.pos
#
#    @write_pos.setter
#    def write_pos(self, val):
#        self.pos = val
#
#    def set_state(self, st):
#        super(SimFile, self).set_state(st)
#
#        if isinstance(self.pos, (int, long)):
#            self.pos = claripy.BVV(self.pos, st.arch.bits)
#
#        if isinstance(self.size, (int, long)):
#            self.size = claripy.BVV(self.size, st.arch.bits)
#
#        self.content.set_state(st)
#
#    def variables(self):
#        """
#        :return: the symbolic variable names associated with the file.
#        """
#        return self.content.mem._name_mapping.keys()
#
#    def close(self):
#        l.debug("File %s closed.", self.name)
#        self.closed = True
#        return 0
#
#    def read(self, dst_addr, length):
#        """
#        Reads some data from the current (or provided) position of the file.
#
#        :param dst_addr:    If specified, the data is written to that address.
#        :param length:      The length of the read.
#        :return:            The length of the read.
#        """
#
#        orig_length = length
#        real_length = length
#        max_length = length
#
#        if self.size is not None:
#            max_length = self.size - self.pos
#
#        # TODO: check file close status
#
#        # check if we need to concretize the length
#        if (
#            sim_options.CONCRETIZE_SYMBOLIC_FILE_READ_SIZES in self.state.options and
#            (self.state.se.symbolic(orig_length) or self.state.se.symbolic(max_length))
#        ):
#            orig_max = self.state.se.max_int(orig_length)
#            self.state.add_constraints(orig_length == orig_max)
#            real_length = min(orig_max, self.state.se.max_int(max_length))
#
#        if self.size is not None:
#            length_constraint = self.pos + real_length <= self.size
#            if (self.state.se.symbolic(real_length) or self.state.se.symbolic(max_length)) and \
#                    self.state.se.satisfiable(extra_constraints=(length_constraint,)):
#                self.state.add_constraints(length_constraint)
#            elif not self.state.se.symbolic(real_length) or not self.state.se.symbolic(max_length):
#                real_length = min(self.state.se.eval(max_length), self.state.se.eval(real_length))
#
#        self.content.copy_contents(dst_addr, self.pos, real_length , dst_memory=self.state.memory)
#        self.read_pos += _deps_unpack(real_length)[0]
#        return real_length
#
#    def read_from(self, length):
#
#        # TODO: check file close status
#
#        read_length = length
#        if self.size is not None:
#            remaining = self.size - self.pos
#            read_length = self.state.se.If(remaining < length, remaining, length)
#
#        data = self.content.load(self.pos, read_length)
#        self.read_pos += _deps_unpack(read_length)[0]
#        return data
#
#    # Writes some data to the current position of the file.
#    def write(self, content, length):
#        # TODO: something about length
#        # TODO: check file close status
#
#        self.content.store(self.pos, content)
#        self.write_pos += _deps_unpack(length)[0]
#        return length
#
#    # Seeks to a position in the file.
#    def seek(self, where):
#        # TODO: check file close status
#
#        if isinstance(where, (int, long)):
#            where = self.state.se.BVV(where, self.state.arch.bits)
#        self.pos = where
#
#    # Copies the SimFile object.
#    def copy(self):
#        return SimFile(self.name, self.mode, pos=self.pos, content=self.content.copy(), size=self.size, closed=self.closed)
#
#    def all_bytes(self):
#        indexes = self.content.mem.keys()
#        if len(indexes) == 0:
#            return self.state.se.BVV("")
#
#        min_idx = min(indexes)
#        max_idx = max(indexes)
#        buff = [ ]
#        for i in range(min_idx, max_idx+1):
#            buff.append(self.content.load(i, 1))
#        return self.state.se.Concat(*buff)
#
#    def concretize(self, **kwargs):
#        """
#        Returns a concrete value for this file satisfying the current state constraints.
#
#        Or: generate a testcase for this file.
#        """
#        return self.state.se.eval(self.all_bytes(), cast_to=str, **kwargs)
#
#    def merge(self, others, merge_conditions, common_ancestor=None):
#        """
#        Merges the SimFile object with `others`.
#        """
#        if not all(isinstance(oth, SimFile) for oth in others):
#            raise SimMergeError("merging files of different types is not supported")
#
#        all_files = list(others) + [ self ]
#
#        if len(set(o.pos for o in all_files)) > 1:
#            l.warning("Cheap HACK to support multiple file positions in a merge.")
#            # self.pos = max(o.pos for o in all_files)
#            # max cannot be used as file positions might be symbolic.
#            #max_pos = None
#            #for o in all_files:
#            #   if max_pos is not None:
#            #       comp = self.state.se.simplify(max_pos >= o.pos)
#            #       #if self.state.se.symbolic(comp):
#            #       #   #import ipdb; ipdb.set_trace()
#            #       #   raise SimMergeError("merging file positions with symbolic max position is not ye supported (TODO)")
#
#            #       max_pos = o.pos if self.state.se.is_false(comp) else max_pos
#            #   else:
#            #       max_pos = o.pos
#            self.pos = max(
#                self.state.se.max(self.pos),
#                max(o.state.se.max(o.pos) for o in others)
#            )
#
#        #if len(set(o.name for o in all_files)) > 1:
#        #   raise SimMergeError("merging file names is not yet supported (TODO)")
#
#        #if len(set(o.mode for o in all_files)) > 1:
#        #   raise SimMergeError("merging modes is not yet supported (TODO)")
#
#        return self.content.merge(
#            [ o.content for o in others ], merge_conditions, common_ancestor=common_ancestor
#        )
#
#    def widen(self, others):
#        return self.merge(others, [])
#
#
#class SimDialogue(SimFile):
#    """
#    Emulates a dialogue with a program. Enables us to perform concrete short reads.
#    """
#
#    def __init__(self, name, mode=None, pos=0, content=None, size=None, dialogue_entries=None):
#        super(SimDialogue, self).__init__(name, mode=mode, pos=pos, content=content, size=size)
#
#        self.dialogue_entries = [ ] if dialogue_entries is None else dialogue_entries
#
#    def set_state(self, st):
#        super(SimDialogue, self).set_state(st)
#
#        if isinstance(self.pos, (int, long)):
#            self.pos = claripy.BVV(self.pos, st.arch.bits)
#
#        if isinstance(self.size, (int, long)):
#            self.size = claripy.BVV(self.size, st.arch.bits)
#
#        self.content.set_state(st)
#
#    def add_dialogue_entry(self, dialogue_len):
#        """
#        Add a new dialogue piece to the end of the dialogue.
#        """
#
#        self.dialogue_entries.append(dialogue_len)
#
#    def read(self, dst_addr, length):
#        """
#        Reads some data from current dialogue entry, emulates short reads.
#        """
#
#        # make sure there is a current dialogue
#        try:
#            # this should always be a concrete value
#            current_pkt_length = self.dialogue_entries.pop(0)
#        except IndexError:
#            return 0
#
#        # two things can happen here:
#        #  * we have a less than or equal amount of concrete content than the request read length
#        #  * we have more concrete content than what was requested
#
#        # we assume the length passed to read can always be concretized to a single value
#        # because our dialogue entries will always be preconstrained
#        lengths = self.state.se.eval_upto(length, 2)
#        if len(lengths) > 1:
#            raise ValueError("read called with a symbolic length which can be more than a single value")
#        length_c = lengths[0]
#
#        if current_pkt_length <= length_c:
#            self.content.copy_contents(dst_addr, self.pos, current_pkt_length, dst_memory=self.state.memory)
#            return_length = current_pkt_length
#
#        else:
#            self.content.copy_contents(dst_addr, self.pos, length_c, dst_memory=self.state.memory)
#            return_length = length_c
#
#            # now add the remaining content as a new dialogue on top of the dialogue list
#            leftovers = current_pkt_length - length_c
#
#            self.dialogue_entries.insert(0, leftovers)
#
#        self.pos += return_length
#        return return_length
#
#    # Copies the SimDialogue object.
#    def copy(self):
#        return SimDialogue(self.name, mode=self.mode, pos=self.pos, content=self.content.copy(), size=self.size, dialogue_entries=list(self.dialogue_entries))

from ..errors import SimMergeError, SimFileError, SimSolverError

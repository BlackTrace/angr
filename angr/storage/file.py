import claripy
import logging
import itertools

from .memory_object import SimMemoryObject
from ..state_plugins.plugin import SimStatePlugin
from ..state_plugins.sim_action_object import SimActionObject
from ..state_plugins.symbolic_memory import SimSymbolicMemory
from .. import sim_options

l = logging.getLogger("angr.storage.file")

file_counter = itertools.count()
dialogue_counter = itertools.count()

class Flags: # pylint: disable=W0232,
    O_RDONLY = 0
    O_WRTONLY = 1
    O_RDWR = 2
    O_APPEND = 4096
    O_ASYNC = 64
    O_CLOEXEC = 512
    # TODO mode for this flag
    O_CREAT = 256
    O_DIRECT = 262144
    O_DIRECTORY = 2097152
    O_EXCL = 2048
    O_LARGEFILE = 1048576
    O_NOATIME = 16777216
    O_NOCTTY = 1024
    O_NOFOLLOW = 4194304
    O_NONBLOCK = 8192
    O_NODELAY = 8192
    O_SYNC = 67174400
    O_TRUNC = 1024


def _deps_unpack(a):
    if isinstance(a, SimActionObject):
        return a.ast, a.reg_deps, a.tmp_deps
    else:
        return a, None, None

class SimFileBase(SimStatePlugin):
    """
    SimFiles are the storage mechanisms used by SimFileDescriptors.

    Different types of SimFiles can have drastically different interfaces, and as a result there's not much that can be
    specified on this base class.

    :ivar name:     The name of the file. Purely for cosmetic purposes
    :ivar ident:    The identifier of the file, typically autogenerated from the name and a nonce. Purely for cosmetic
                    purposes, but does appear in symbolic values autogenerated in the file.
    :ivar seekable: Bool indicating whether seek operations on this file should succeed.
    :ivar writable: Bool indicating whether writing to this file is allowed.
    """

    seekable = False

    def __init__(self, name, writable=True, ident=None, **kwargs):
        self.name = name
        self.ident = ident
        self.writable = writable

        if ident is None:
            nice_name = self.name if all(0x20 <= ord(c) <= 0x7f for c in self.name) else '???'
            self.ident = 'file_%d_%s' % (next(file_counter), nice_name)

        if 'memory_id' in kwargs:
            kwargs['memory_id'] = self.ident
        super(SimFileBase, self).__init__(**kwargs)

    def concretize(self):
        """
        Return a concretization of the contents of the file. The type of the return value of this method will vary
        depending on which kind of SimFile you're using.
        """
        raise NotImplementedError

    def read(self, pos, size):
        """
        Read some data from the file.

        :param pos:     The offset in the file to read from. May be ignored if the file is a stream or device.
        :param size:    The size to read. May be symbolic.
        :return:        A tuple of the data read (a bitvector of the length that is the maximum length of the read) and the actual size of the read.
        """
        raise NotImplementedError

    def write(self, pos, data, size=None):
        """
        Write some data to the file.

        :param pos:     The offset in the file to write to. May be ignored if the file is a stream or device.
        :param data:    The data to write as a bitvector
        :param size:    The optional size of the data to write. If not provided will default to the length of the data.
                        Must be constrained to less than or equal to the size of the data.
        """
        raise NotImplementedError

class SimFile(SimFileBase, SimSymbolicMemory):
    """
    The normal SimFile is meant to files on disk. It subclasses SimSymbolicMemory so loads and stores to/from
    it are very simple.

    :param name:        The name of the file
    :param content:     Optional initial content for the file as a string or bitvector
    :param size:        Optional size of the file. If content is specified, it defaults to its length, otherwise to an
                        unconstrained symbolic variable.
    :param seekable:    Optional bool indicating whether seek operations on this file should succeed, default True.
    :param writable:    Whether writing to this file is allowed

    :ivar size:         The size of the file. Reads past this size will be truncated. Symbolic-valued sizes will be
                        handled as best as possible.
    """
    def __init__(self, name, content=None, size=None, seekable=True, writable=True, ident=None, **kwargs):
        super(SimFile, self).__init__(name, writable=writable, ident=ident, memory_id='file', **kwargs)
        self.size = size
        self.seekable = seekable

        # this is hacky because we need to work around not having a state yet
        if type(content) is bytes:
            content = claripy.BVV(content)
        elif type(content) is claripy.BV:
            pass
        else:
            raise TypeError("Can't handle SimFile content of type %s" % type(content))

        if content is not None:
            mo = SimMemoryObject(content, 0, length=len(content)//8)
            self.mem.store_memory_object(mo)

            if self.size is None:
                self.size = len(content) // 8

    def set_state(self, state):
        super(SimFile, self).set_state(state)
        if self.size is None and sim_options.UNKNOWN_FILES_HAVE_EOF in state.options:
            self.size = claripy.BVS('filesize_%s' % self.ident, state.arch.bits)

    def concretize(self):
        """
        Return a concretization of the contents of the file, as a flat bytestring.
        """
        if self.size is None:
            size = max(self.mem.keys())
        else:
            size = self.state.solver.min(self.size)

        data = self.load(0, size)
        return self.state.solver.eval(data, cast_to=str)

    def read(self, pos, size):
        # If it's not possible to EOF (because there's no EOF), this is very simple!
        if self.size is None:
            return self.load(pos, size), size

        # This is the size if we're reading to the end of the file
        absolute_max_size = self.size - pos
        absolute_max_size = claripy.If(claripy.SLE(absolute_max_size, 0), 0, absolute_max_size)

        # try to frontload some constraint solving to see if it's impossible for this read to EOF
        if self.state.solver.satisfiable(extra_constraints=(size > absolute_max_size,)):
            # it's possible to EOF
            real_size = claripy.If(size >= absolute_max_size, absolute_max_size, size)
            return self.load(pos, absolute_max_size), real_size
        else:
            # it's not possible to EOF
            # we don't need to constrain or min/max the output size because there are already constraints asserting
            # that the total filesize is pretty big
            return self.load(pos, size), size

    def write(self, pos, data, size=None):
        if size is None:
            size = len(data) // 8
        # \(_^^)/
        self.store(pos, data, size=size)
        if self.size is not None:
            new_end = _deps_unpack(pos + size)[0] # decline to store SAO
            self.size = claripy.If(new_end > self.size, new_end, self.size)

    @SimStatePlugin.memo
    def copy(self, _):
        #l.debug("Copying %d bytes of memory with id %s." % (len(self.mem), self.id))
        return SimFile(name=self.name, size=self.size, seekable=self.seekable, writable=self.writable, ident=self.ident,
            mem=self.mem.branch(),
            memory_id=self.id,
            endness=self.endness,
            abstract_backer=self._abstract_backer,
            read_strategies=[ s.copy() for s in self.read_strategies ],
            write_strategies=[ s.copy() for s in self.write_strategies ],
            stack_region_map=self._stack_region_map,
            generic_region_map=self._generic_region_map
        )

    def merge(self, others, merge_conditions, common_ancestor=None):
        if not all(isinstance(o, SimFile) for o in others):
            raise SimMergeError("Can't merge files of disparate type")

        all_files = list(others) + [ self ]

        if all(o.size is None for o in all_files):
            pass
        elif any(o.size is None for o in all_files):
            raise SimMergeError("Can't merge files where some have sizes and some don't")
        else:
            self.size = self.state.solver.ite_cases(zip(merge_conditions, (o.size for o in others)), self.size)

        return super(SimFile, self).merge(
            [ super(SimFile, o) for o in others ], merge_conditions, common_ancestor
        )

    def widen(self, others):
        return self.merge(others, []) # TODO this seems... wrong


class SimPackets(SimFileBase):
    """
    The SimPackets is meant to model inputs whose content is delivered a series of asynchronous chunks. The data is
    stored as a list of read or write results. For symbolic sizes, state.libc.max_packet_size will be respected. If
    the SHORT_READS option is enabled, reads will return a symbolic size constrained to be less than or equal to the
    requested size.

    A SimPackets cannot be used for both reading and writing - for socket objects that can be both read and written to
    you should use a file descriptor to multiplex the read and write operations into two separate file storage
    mechanisms.

    :param name:        The name of the file, for cosmetic purposes
    :param write_mode:  Whether this file is opened in read or write mode. If this is unspecified it will be
                        autodetected.
    :param content:     Some initial content to use for the file. Can be a list of bytestrings or a list of tuples in
                        the format of the content instance variable below.

    :ivar write_mode:   See the eponymous parameter
    :ivar content:      A list of packets, tuples of data (as a bitvector with the maximum length the packet could be)
                        and the actual length of the packet
    """
    def __init__(self, name, write_mode=None, content=None, writable=True, ident=None, **kwargs):
        super(SimPackets, self).__init__(name, writable=writable, ident=ident, **kwargs)

        self.write_mode = write_mode
        self.content = content

        if self.content is None:
            self.content = []
        else:
            self.content = [
                    x if type(x) is tuple \
                    else (x, len(x) // 8) if type(x) is claripy.BV \
                    else (claripy.BVV(x), len(x)) if type(x) is bytes \
                    else None \
                    for x in self.content]
            if any(x is None for x in self.content):
                raise TypeError("Bad type in initial SimPacket content")

    def concretize(self, **kwargs):
        """
        Returns a list of the packets read or written as bytestrings.
        """
        lengths = [self.state.solver.eval(x[1], **kwargs) for x in self.content]
        kwargs['cast_to'] = bytes
        return ['' if i == 0 else self.state.solver.eval(x[0].get_bytes(0, i), **kwargs) for i, x in zip(lengths, self.content)]

    def read(self, addr, size):
        """
        Read a packet from the stream.

        :param int addr:    The packet number to read from the sequence of the stream. May be None to append to the stream.
        :param size:        The size to read. May be symbolic.
        :return:            A tuple of the data read (a bitvector of the length that is the maximum length of the read) and the actual size of the read.
        """
        # sanity check on read/write modes
        if self.write_mode is None:
            self.write_mode = False
        elif self.write_mode is True:
            raise SimFileError("Cannot read and write to the same SimPackets")

        # sanity check on packet number and determine if data is already present
        if addr is None:
            addr = len(self.content)
        if addr < 0:
            raise SimFileError("SimPacket.read(%d): Negative packet number?", addr)
        elif addr > len(self.content):
            raise SimFileError("SimPacket.read(%d): Packet number is past frontier of %d?", addr, len(self.content))
        elif addr != len(self.content):
            _, realsize = self.content[addr]
            self.state.solver.add(size <= realsize)
            if not self.state.solver.satisfiable():
                raise SimFileError("Packet read size constraint made state unsatisfiable???")
            return self.content[addr]

        # The read is on the frontier. let's generate a new packet.
        orig_size = size
        max_size = None

        # if short reads are enabled, replace size with a symbol
        if sim_options.SHORT_READS in self.state.options:
            size = self.state.solver.BVS('packetsize_%d_%s' % (len(self.content), self.ident), self.state.arch.bits)
            self.state.solver.add(size <= orig_size)

        # figure out the maximum size of the read
        if not self.state.solver.symbolic(size):
            max_size = self.state.solver.eval(size)
        elif self.state.solver.satisfiable(extra_constraints=(size <= self.state.libc.max_packet_size,)):
            l.info("Constraining symbolic packet size to be less than %d", self.state.libc.max_packet_size)
            self.state.solver.add(size <= self.state.libc.max_packet_size)
            if not self.state.solver.symbolc(orig_size):
                max_size = min(orig_size, self.state.libc.max_packet_size)
            else:
                max_size = self.state.solver.max(size)
        else:
            max_size = self.state.solver.min(size)
            l.warning("Could not constrain symbolic packet size to <= %d; using minimum %d for size", self.state.libc.max_packet_size, max_size)
            self.state.solver.add(size == max_size)

        # generate the packet data and return it
        data = claripy.BVS('packet_%d_%s' % (len(self.content), self.ident), max_size * 8)
        packet = (data, size)
        self.content.append(packet)
        return packet

    def write(self, addr, data, size=None):
        """
        Write a packet to the stream.

        :param int addr:    The packet number to write in the sequence of the stream. May be None to append to the stream.
        :param data:        The data to write, as a string or bitvector.
        :param size:        The optional size to write. May be symbolic; must be constrained to at most the size of data.
        """
        # sanity check on read/write modes
        if self.write_mode is None:
            self.write_mode = True
        elif self.write_mode is False:
            raise SimFileError("Cannot read and write to the same SimPackets")

        if type(data) is bytes:
            data = claripy.BVV(data)
        if size is None:
            size = len(data) // 8

        # sanity check on packet number and determine if data is already present
        if addr < 0:
            raise SimFileError("SimPacket.write(%d): Negative packet number?", addr)
        elif addr > len(self.content):
            raise SimFileError("SimPacket.write(%d): Packet number is past frontier of %d?", addr, len(self.content))
        elif addr != len(self.content):
            realdata, realsize = self.content[addr]
            maxlen = max(len(realdata), len(data))
            self.state.solver.add(realdata[maxlen-1:0] == data[maxlen-1:0])
            self.state.solver.add(size == realsize)
            if not self.state.solver.satisfiable():
                raise SimFileError("Packet write equality constraints made state unsatisfiable???")
            return

        # write it out!
        self.content.append((data, size))

    @SimStatePlugin.memo
    def copy(self, memo):
        return SimPackets(self.name, write_mode=self.write_mode, content=self.content, ident=self.ident)

    def merge(self, others, conditions, _=None):
        for o in others:
            if o.write_mode is None:
                continue
            elif self.write_mode is None:
                self.write_mode = o.write_mode
            elif self.write_mode is not o.write_mode:
                raise SimMergeError("Can't merge SimPackets with disparate write_mode")

        for o in others:
            if len(o.content) != len(self.content):
                l.warning("Can't merge SimPackets with disparate number of packets")
                return False

        for i, default in enumerate(self.content):
            max_data_length = max(len(default[0]), max(len(o.content[i][0]) for o in others))
            merged_data = self.state.solver.ite_cases(
                zip(
                    conditions,
                    (o.content[i][0].concat(claripy.BVV(0, max_data_length - len(o.content[i][0]))) for o in others)
                ), default[0])
            merged_size = self.state.solver.ite_cases(zip(conditions, (o.content[i][1] for o in others)), default[1])
            self.content[i] = (merged_data, merged_size)

        return True

    def widen(self, others):
        return self.merge(others, [])

class SimFileConcrete(SimFileBase):
    """
    A SimFile which forwards all its reads and writes to the host filesystem.

    :param host_path:   The path in the host filesystem to use
    :param writable:    Whether to open this file for writing. If the file may not be opened for writing, this will be
                        ignored.
    """
    def __init__(self, host_path, writable=False):
        super(SimFileConcrete, self).__init__(host_path, writable=writable)
        self.host_path = host_path
        try:
            self.host_file = open(host_path, 'r+b' if writable else 'rb')
        except OSError:
            if not writable:
                raise
            self.host_file = open(host_path, 'rb')

    def concretize(self):
        self.host_file.seek(0)
        return self.host_file.read()

    def read(self, pos, size):
        conc_size = self.state.solver.max(size)
        if self.state.solver.symbolic(size):
            self.state.solver.add(size == conc_size)
            l.info("Concretizing read size for concrete filesystem to %d", conc_size)

        conc_pos = self.state.solver.eval(pos)
        self.state.solver.add(pos == conc_pos)

        self.host_file.seek(conc_pos)
        data = self.host_file.read(conc_size)
        return self.state.solver.BVV(data), len(data)

    def write(self, pos, data, size=None):
        if size is None:
            size = len(data)

        conc_size = self.state.solver.max(size)
        if self.state.solver.symbolic(size):
            self.state.solver.add(size == conc_size)
            l.info("Concretizing write size for concrete filesystem to %d", conc_size)

        data_slice = data.get_bytes(0, conc_size)
        conc_data = self.state.solver.eval(data_slice, cast_to=str)
        if self.state.solver.symbolic(data_slice):
            self.state.solver.add(data_slice == conc_data)
            l.info("Concretizing write data for concrete filesystem to %r", conc_data)

        conc_pos = self.state.solver.eval(pos)
        self.state.solver.add(pos == conc_pos)

        self.host_file.seek(conc_pos)
        self.host_file.write(conc_data)

    def copy(self, _):
        # this holds no mutable data
        return self

    def merge(self, others, conditions, ancestor=None): # pylint: disable=unused-argument
        l.error("The concept of merging concrete files doesn't make sense...")
        return False

    def widen(self, others):
        return self.merge(others, [])


class SimFileDescriptorBase(SimStatePlugin):
    """
    The base class for implementations of POSIX file descriptors.

    All file descriptors should respect the CONCRETIZE_SYMBOLIC_{READ,WRITE}_SIZES state options.
    """

    def read(self, addr, size):
        """
        Reads some data from the file.

        :param addr:    The address to write the read data into memory
        :param size:    The requested length of the read
        :return:        The real length of the read
        """
        raise NotImplementedError

    def write(self, addr, size):
        """
        Writes some data into the file.

        :param addr:    The address to read the data to write from in memory
        :param size:    The requested size of the write
        :return:        The real length of the write
        """
        raise NotImplementedError

    @staticmethod
    def _do_read(simfile, pos, addr, size):
        # check if we need to concretize the length
        if sim_options.CONCRETIZE_SYMBOLIC_FILE_READ_SIZES in simfile.state.options \
                and simfile.state.se.symbolic(size):
            try:
                size = simfile.state.solver.max(size, extra_constraints=(size <= simfile.state.libc.max_packet_size,))
            except SimSolverError:
                size = simfile.state.solver.min(size)
            l.info("Concretizing symbolic read size to %d", size)

        data, realsize = simfile.read(pos, size)
        simfile.state.memory.write(addr, data, size=realsize)
        return realsize

    @staticmethod
    def _do_write(simfile, pos, addr, size):
        # check if we need to concretize the length
        if sim_options.CONCRETIZE_SYMBOLIC_WRITE_SIZES in simfile.state.options \
                and simfile.state.se.symbolic(size):
            try:
                size = simfile.state.solver.max(size, extra_constraints=(size <= simfile.state.libc.max_packet_size,))
            except SimSolverError:
                size = simfile.state.solver.min(size)
            l.info("Concretizing symbolic write size to %d", size)

        data = simfile.state.memory.read(addr, size)
        simfile.write(pos, data, size)
        return size

class SimFileDescriptor(SimFileDescriptorBase):
    """
    A simple file descriptor forwarding reads and writes to a SimFile. Contains information about
    the current opened state of the file, such as the flags or (if relevant) the current position.

    :ivar file:     The SimFile described to by this descriptor
    :ivar flags:    The mode that the file descriptor was opened with, a bitfield of flags
    """
    def __init__(self, simfile, flags):
        super(SimFileDescriptor, self).__init__()
        self.file = simfile
        self._pos = 0
        self.flags = flags

    def read(self, addr, size):
        realsize = self._do_read(self.file, self._pos, addr, size)

        if hasattr(self.file, 'size'):
            self._pos = _deps_unpack(self._pos + realsize)[0]
        else:
            self._pos += 1

        return realsize

    def write(self, addr, size):
        if self.flags & Flags.O_APPEND and hasattr(self.file, 'size'):
            self._pos = self.file.size

        realsize = self._do_write(self.file, self._pos, addr, size)

        if hasattr(self.file, 'size'):
            self._pos = _deps_unpack(self._pos + realsize)[0]
        else:
            self._pos += 1

        return realsize

    def seek(self, offset, whence='start'):
        """
        Seek the file descriptor to a different position in the file.

        :param offset:  The offset to seek to, interpreted according to whence
        :param whence:  What the offset is relative to; one of the strings "start", "current", or "end"
        :return:        A symbolic boolean describing whether the seek succeeded or not
        """
        if not self.file.seekable:
            return claripy.false

        if whence == 'start':
            new_pos = offset
        elif whence == 'current':
            new_pos = self._pos + offset
        elif whence == 'end':
            if self.file.size is None:
                raise SimFileError("Can't seek based on end of file with no end")
            new_pos = self.file.size + offset

        success_condition = claripy.SGE(new_pos, 0)
        if self.file.size is not None:
            success_condition = claripy.And(success_condition, claripy.SLE(new_pos, self.file.size))
        self._pos = _deps_unpack(claripy.If(success_condition, new_pos, self._pos))[0]
        return success_condition

    def tell(self):
        """
        :return:    The current offset in the file, or None if the file has no concept of offsets
        """
        if self.file.seekable:
            return None
        return self._pos

    def set_state(self, state):
        super(SimFileDescriptor, self).set_state(state)
        self.file.set_state(state)

    @SimStatePlugin.memo
    def copy(self, memo):
        c = SimFileDescriptor(self.file.copy(memo), self.flags)
        c._pos = self._pos
        return c

    def merge(self, others, conditions, ancestor=None):
        if not all(type(o) is type(self) for o in others):
            l.error("Cannot merge SimFileDescriptors of disparate types")
            return False
        if not all(o.flags == self.flags for o in others):
            l.error("Cannot merge SimFileDescriptors of disparate flags")
            return False

        if hasattr(self.file, 'size'):
            self._pos = self.state.solver.ite_cases(zip(conditions, (o._pos for o in others)), self._pos)
        else:
            if not all(o._pos == self._pos for o in others):
                l.error("Cannot merge SimFileDescriptors over SimPackets with disparate number of packets")
                return False

        return self.file.merge([o.file for o in others], conditions, ancestor)

    def widen(self, others):
        return self.merge(others, [])

class SimFileDescriptorDuplex(SimFileDescriptorBase):
    """
    A file descriptor that refers to two file storage mechanisms, one to read from and one to write to.

    :param read_file:   The SimFile to read from
    :param write_file:  The SimFile to write to

    :ivar read_file:
    :ivar write_file:
    """
    def __init__(self, read_file, write_file):
        super(SimFileDescriptorDuplex, self).__init__()
        self.read_file = read_file
        self.write_file = write_file

        self._read_pos = 0
        self._write_pos = 0

    def read(self, addr, size):
        realsize = self._do_read(self.read_file, self._read_pos, addr, size)

        if hasattr(self.read_file, 'size'):
            self._read_pos = _deps_unpack(self._read_pos + realsize)[0]
        else:
            self._read_pos += 1

        return realsize

    def write(self, addr, size):
        realsize = self._do_write(self.write_file, self._write_pos, addr, size)

        if hasattr(self.write_file, 'size'):
            self._write_pos = _deps_unpack(self._write_pos + realsize)[0]
        else:
            self._write_pos += 1

        return realsize

    def set_state(self, state):
        super(SimFileDescriptorDuplex, self).set_state(state)
        self.read_file.set_state(state)
        self.write_file.set_state(state)

    @SimStatePlugin.memo
    def copy(self, memo):
        c = SimFileDescriptorDuplex(self.read_file.copy(memo), self.write_file.copy(memo))
        c._read_pos = self._read_pos
        c._write_pos = self._write_pos
        return c

    def merge(self, others, conditions, ancestor=None):
        if not all(type(o) is type(self) for o in others):
            l.error("Cannot merge SimFileDescriptors of disparate types")
            return False

        if hasattr(self.read_file, 'size'):
            self._read_pos = self.state.solver.ite_cases(zip(conditions, (o._read_pos for o in others)), self._read_pos)
        else:
            if not all(o._read_pos == self._read_pos for o in others):
                l.error("Cannot merge SimFileDescriptors over SimPackets with disparate number of packets")
                return False

        if hasattr(self.write_file, 'size'):
            self._write_pos = self.state.solver.ite_cases(zip(conditions, (o._write_pos for o in others)), self._write_pos)
        else:
            if not all(o._write_pos == self._write_pos for o in others):
                l.error("Cannot merge SimFileDescriptors over SimPackets with disparate number of packets")
                return False

        return self.read_file.merge([o.read_file for o in others], conditions, ancestor) \
            and self.write_file.merge([o.write_file for o in others], conditions, ancestor)

    def widen(self, others):
        return self.merge(others, [])

# OLD
#class SimFile(SimStatePlugin):
#    """
#    Represents a file.
#    """
#
#    # Creates a SimFile
#    def __init__(self, name, mode, pos=0, content=None, size=None, closed=None):
#        super(SimFile, self).__init__()
#        self.name = name
#        self.mode = mode
#
#        self.pos = pos
#
#        self.size = size
#
#        self.content = SimSymbolicMemory(memory_id="file_%s_%d" % (name, file_counter.next())) if content is None else content
#        self.closed = False if closed is None else closed
#
#    @property
#    def read_pos(self):
#        return self.pos
#
#    @read_pos.setter
#    def read_pos(self, val):
#        self.pos = val
#
#    @property
#    def write_pos(self):
#        return self.pos
#
#    @write_pos.setter
#    def write_pos(self, val):
#        self.pos = val
#
#    def set_state(self, st):
#        super(SimFile, self).set_state(st)
#
#        if isinstance(self.pos, (int, long)):
#            self.pos = claripy.BVV(self.pos, st.arch.bits)
#
#        if isinstance(self.size, (int, long)):
#            self.size = claripy.BVV(self.size, st.arch.bits)
#
#        self.content.set_state(st)
#
#    def variables(self):
#        """
#        :return: the symbolic variable names associated with the file.
#        """
#        return self.content.mem._name_mapping.keys()
#
#    def close(self):
#        l.debug("File %s closed.", self.name)
#        self.closed = True
#        return 0
#
#    def read(self, dst_addr, length):
#        """
#        Reads some data from the current (or provided) position of the file.
#
#        :param dst_addr:    If specified, the data is written to that address.
#        :param length:      The length of the read.
#        :return:            The length of the read.
#        """
#
#        orig_length = length
#        real_length = length
#        max_length = length
#
#        if self.size is not None:
#            max_length = self.size - self.pos
#
#        # TODO: check file close status
#
#        # check if we need to concretize the length
#        if (
#            sim_options.CONCRETIZE_SYMBOLIC_FILE_READ_SIZES in self.state.options and
#            (self.state.se.symbolic(orig_length) or self.state.se.symbolic(max_length))
#        ):
#            orig_max = self.state.se.max_int(orig_length)
#            self.state.add_constraints(orig_length == orig_max)
#            real_length = min(orig_max, self.state.se.max_int(max_length))
#
#        if self.size is not None:
#            length_constraint = self.pos + real_length <= self.size
#            if (self.state.se.symbolic(real_length) or self.state.se.symbolic(max_length)) and \
#                    self.state.se.satisfiable(extra_constraints=(length_constraint,)):
#                self.state.add_constraints(length_constraint)
#            elif not self.state.se.symbolic(real_length) or not self.state.se.symbolic(max_length):
#                real_length = min(self.state.se.eval(max_length), self.state.se.eval(real_length))
#
#        self.content.copy_contents(dst_addr, self.pos, real_length , dst_memory=self.state.memory)
#        self.read_pos += _deps_unpack(real_length)[0]
#        return real_length
#
#    def read_from(self, length):
#
#        # TODO: check file close status
#
#        read_length = length
#        if self.size is not None:
#            remaining = self.size - self.pos
#            read_length = self.state.se.If(remaining < length, remaining, length)
#
#        data = self.content.load(self.pos, read_length)
#        self.read_pos += _deps_unpack(read_length)[0]
#        return data
#
#    # Writes some data to the current position of the file.
#    def write(self, content, length):
#        # TODO: something about length
#        # TODO: check file close status
#
#        self.content.store(self.pos, content)
#        self.write_pos += _deps_unpack(length)[0]
#        return length
#
#    # Seeks to a position in the file.
#    def seek(self, where):
#        # TODO: check file close status
#
#        if isinstance(where, (int, long)):
#            where = self.state.se.BVV(where, self.state.arch.bits)
#        self.pos = where
#
#    # Copies the SimFile object.
#    def copy(self):
#        return SimFile(self.name, self.mode, pos=self.pos, content=self.content.copy(), size=self.size, closed=self.closed)
#
#    def all_bytes(self):
#        indexes = self.content.mem.keys()
#        if len(indexes) == 0:
#            return self.state.se.BVV("")
#
#        min_idx = min(indexes)
#        max_idx = max(indexes)
#        buff = [ ]
#        for i in range(min_idx, max_idx+1):
#            buff.append(self.content.load(i, 1))
#        return self.state.se.Concat(*buff)
#
#    def concretize(self, **kwargs):
#        """
#        Returns a concrete value for this file satisfying the current state constraints.
#
#        Or: generate a testcase for this file.
#        """
#        return self.state.se.eval(self.all_bytes(), cast_to=str, **kwargs)
#
#    def merge(self, others, merge_conditions, common_ancestor=None):
#        """
#        Merges the SimFile object with `others`.
#        """
#        if not all(isinstance(oth, SimFile) for oth in others):
#            raise SimMergeError("merging files of different types is not supported")
#
#        all_files = list(others) + [ self ]
#
#        if len(set(o.pos for o in all_files)) > 1:
#            l.warning("Cheap HACK to support multiple file positions in a merge.")
#            # self.pos = max(o.pos for o in all_files)
#            # max cannot be used as file positions might be symbolic.
#            #max_pos = None
#            #for o in all_files:
#            #   if max_pos is not None:
#            #       comp = self.state.se.simplify(max_pos >= o.pos)
#            #       #if self.state.se.symbolic(comp):
#            #       #   #import ipdb; ipdb.set_trace()
#            #       #   raise SimMergeError("merging file positions with symbolic max position is not ye supported (TODO)")
#
#            #       max_pos = o.pos if self.state.se.is_false(comp) else max_pos
#            #   else:
#            #       max_pos = o.pos
#            self.pos = max(
#                self.state.se.max(self.pos),
#                max(o.state.se.max(o.pos) for o in others)
#            )
#
#        #if len(set(o.name for o in all_files)) > 1:
#        #   raise SimMergeError("merging file names is not yet supported (TODO)")
#
#        #if len(set(o.mode for o in all_files)) > 1:
#        #   raise SimMergeError("merging modes is not yet supported (TODO)")
#
#        return self.content.merge(
#            [ o.content for o in others ], merge_conditions, common_ancestor=common_ancestor
#        )
#
#    def widen(self, others):
#        return self.merge(others, [])
#
#
#class SimDialogue(SimFile):
#    """
#    Emulates a dialogue with a program. Enables us to perform concrete short reads.
#    """
#
#    def __init__(self, name, mode=None, pos=0, content=None, size=None, dialogue_entries=None):
#        super(SimDialogue, self).__init__(name, mode=mode, pos=pos, content=content, size=size)
#
#        self.dialogue_entries = [ ] if dialogue_entries is None else dialogue_entries
#
#    def set_state(self, st):
#        super(SimDialogue, self).set_state(st)
#
#        if isinstance(self.pos, (int, long)):
#            self.pos = claripy.BVV(self.pos, st.arch.bits)
#
#        if isinstance(self.size, (int, long)):
#            self.size = claripy.BVV(self.size, st.arch.bits)
#
#        self.content.set_state(st)
#
#    def add_dialogue_entry(self, dialogue_len):
#        """
#        Add a new dialogue piece to the end of the dialogue.
#        """
#
#        self.dialogue_entries.append(dialogue_len)
#
#    def read(self, dst_addr, length):
#        """
#        Reads some data from current dialogue entry, emulates short reads.
#        """
#
#        # make sure there is a current dialogue
#        try:
#            # this should always be a concrete value
#            current_pkt_length = self.dialogue_entries.pop(0)
#        except IndexError:
#            return 0
#
#        # two things can happen here:
#        #  * we have a less than or equal amount of concrete content than the request read length
#        #  * we have more concrete content than what was requested
#
#        # we assume the length passed to read can always be concretized to a single value
#        # because our dialogue entries will always be preconstrained
#        lengths = self.state.se.eval_upto(length, 2)
#        if len(lengths) > 1:
#            raise ValueError("read called with a symbolic length which can be more than a single value")
#        length_c = lengths[0]
#
#        if current_pkt_length <= length_c:
#            self.content.copy_contents(dst_addr, self.pos, current_pkt_length, dst_memory=self.state.memory)
#            return_length = current_pkt_length
#
#        else:
#            self.content.copy_contents(dst_addr, self.pos, length_c, dst_memory=self.state.memory)
#            return_length = length_c
#
#            # now add the remaining content as a new dialogue on top of the dialogue list
#            leftovers = current_pkt_length - length_c
#
#            self.dialogue_entries.insert(0, leftovers)
#
#        self.pos += return_length
#        return return_length
#
#    # Copies the SimDialogue object.
#    def copy(self):
#        return SimDialogue(self.name, mode=self.mode, pos=self.pos, content=self.content.copy(), size=self.size, dialogue_entries=list(self.dialogue_entries))

from ..errors import SimMergeError, SimFileError, SimSolverError
